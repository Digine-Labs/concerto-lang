// error_handling_matrix
// Runtime-focused tour of Option/Result + try/catch/throw + ? propagation.

hashmap cache: HashMap<String, Int> = HashMap::new();

fn lookup_required(key: String) -> Option<Int> {
    // ? on Option: None propagates early, Some(v) unwraps to v
    let value = cache.get(key)?;
    Some(value)
}

fn parse_port_with_q(text: String) -> Result<Int, String> {
    let parsed = std::string::parse_int(text)?;
    Ok(parsed)
}

fn dangerous(flag: Bool) -> Result<Int, String> {
    if flag {
        throw "danger signal";
    }
    Ok(42)
}

fn risky_typed(kind: String) -> Result<Int, String> {
    if kind == "type" {
        throw "TypeError: invalid cast";
    }
    if kind == "io" {
        throw "IOError: file not found";
    }
    Ok(100)
}

fn main() {
    cache.set("answer", 42);

    emit("lookup_hit", lookup_required("answer"));
    emit("lookup_miss", lookup_required("missing"));

    match parse_port_with_q("8080") {
        Ok(v) => emit("port", v),
        Err(e) => emit("port_err", e),
    }

    // Untyped catch — catches any thrown value
    let parse_probe = try {
        parse_port_with_q("oops");
        "no error"
    } catch {
        "caught parse error from ?"
    };
    emit("parse_probe", parse_probe);

    let throw_probe = try {
        dangerous(true);
        "no throw"
    } catch {
        emit("caught_throw", "handled");
        "recovered from throw"
    };
    emit("throw_probe", throw_probe);

    // Typed catch — matches specific error types
    let typed_probe = try {
        risky_typed("type");
        "no error"
    } catch String(e) {
        emit("typed_catch", e);
        "caught: ${e}"
    };
    emit("typed_probe", typed_probe);

    let ok_result = dangerous(false);
    emit("danger_ok", ok_result.is_ok());
}
